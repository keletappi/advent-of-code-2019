/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package day11

import intcode.IntcodeComputer

fun main() {

    val panel = mutableMapOf<Loc, Col>()

    var outputValueIsColor = true
    var facing = Facing.W
    var location = Loc(0, 0)

    val initializer = arrayOf(1.toBigInteger()).iterator()
    IntcodeComputer(
            source = PAINTING_ROBOT_BRAIN,
            input = {
                if (initializer.hasNext()) {
                    initializer.next()
                } else {
                    panel.getOrDefault(location, Col.BLACK).ioValue.toBigInteger()
                }
            },
            output = {
                if (outputValueIsColor) {
                    panel[location] = Col.fromIO(it)
                } else {
                    facing = facing.turn(TurnDirection.fromIO(it))
                    location = facing.move(location)
                }
                outputValueIsColor = !outputValueIsColor
            }
    ).execute()

    panel.forEach { println("  ${it.key} + -> ${it.value}") }
    println("# of painted locations: ${panel.size}")
    panel.print()
}

private fun Map<Loc, Col>.print() {
    val maxX = keys.map { it.x }.max()!!
    val minX = keys.map { it.x }.min()!!
    val maxY = keys.map { it.y }.max()!!
    val minY = keys.map { it.y }.min()!!

    val h = maxY - minY + 1
    val w = maxX - minX + 1

    for (x in minX..maxX) {
        for (y in minY..maxY) {
            print(getOrDefault(Loc(x, y), Col.BLACK).textValue)
        }
        println()
    }
}

enum class Col(val ioValue: Int, val textValue: Char) {
    BLACK(0, '.'),
    WHITE(1, '#');

    companion object {
        fun fromIO(io: Int): Col = values().first { it.ioValue == io }
    }

}

data class Loc(val x: Int, val y: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Loc

        if (x != other.x) return false
        if (y != other.y) return false

        return true
    }

    override fun hashCode(): Int {
        var result = x
        result = 31 * result + y
        return result
    }

    override fun toString(): String {
        return "Loc(x=$x, y=$y)"
    }
}

enum class TurnDirection(val ioValue: Int) {
    LEFT(0),
    RIGHT(1);

    companion object {
        fun fromIO(io: Int): TurnDirection = values().first { it.ioValue == io }
    }
}

class Facing(val xUpdate: (n: Int) -> Int,
             val yUpdate: (n: Int) -> Int) {
    companion object {
        val E = Facing({ it + 1 }, { it })
        val W = Facing({ it - 1 }, { it })
        val N = Facing({ it }, { it + 1 })
        val S = Facing({ it }, { it - 1 })
    }

    fun move(old: Loc): Loc = Loc(xUpdate(old.x), yUpdate(old.y))
    fun turn(direction: TurnDirection): Facing = when (this) {
        E -> if (direction == TurnDirection.RIGHT) S else N
        W -> if (direction == TurnDirection.RIGHT) N else S
        S -> if (direction == TurnDirection.RIGHT) W else E
        N -> if (direction == TurnDirection.RIGHT) E else W
        else -> throw RuntimeException("This is an unknown direction: $this")
    }
}
